# 🏆 Problem: Longest Common Prefix

## 📜 Problem Statement
Write a function to find the **longest common prefix** string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

### Example 1:
**Input:**  
`strs = ["flower","flow","flight"]`  
**Output:**  
`"fl"`

### Example 2:
**Input:**  
`strs = ["dog","racecar","car"]`  
**Output:**  
`""`  
**Explanation:** There is no common prefix among the input strings.

### Constraints:
- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` consists of only lowercase English letters if non-empty.

---

## 💡 Intuition
Think of the **first word as a baseline** and try to match its characters one by one with all the other words.  
The moment a mismatch or an out-of-bound index is found in any word, you **stop right there** — because no longer prefix can exist beyond that point.

> Imagine the words stacked vertically:
f l o w e r
f l o w
f l i g h t

yaml
Copy
Edit
We check column by column:  
✅ 'f' matches → ✅ 'l' matches → ❌ 'o' mismatches in the 3rd word → Stop. Prefix = `"fl"`

---

## 🧠 Conceptual Understanding
- We **compare character by character** starting from index 0.
- We rely on the fact that **if the first mismatch happens at position `i`**, the longest common prefix must be from `0` to `i-1`.
- This is an **incremental matching approach** → It’s optimal because:
  - We stop early when mismatch is found.
  - No extra space needed.

---

## ⏱ Time and Space Complexity
| Complexity Type | Value |
|-----------------|-------|
| **Time**        | O(S) where S = sum of all characters in all strings (worst case compares each char) |
| **Space**       | O(1) — No extra space used beyond variables |

---

## 🌳 Recursion / Visualization (Test Case)
For input: `["flower", "flow", "flight"]`

Step 0: f l o w e r
f l o w
f l i g h t
↑
Match (char 'f')

Step 1: f l o w e r
f l o w
f l i g h t
↑
Match (char 'l')

Step 2: f l o w e r
f l o w
f l i g h t
↑
Mismatch (char 'o' vs 'i') → Stop

Final Prefix: "fl"

pgsql
Copy
Edit

---

## 💻 Code Implementation (Java)
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        for (int i = 0; i < strs[0].length(); i++) {
            char c = strs[0].charAt(i);
            for (int j = 1; j < strs.length; j++) {
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
🔄 Other Possible Approaches
Approach	Idea	Time Complexity	Space Complexity	Current?
Brute Force	Take the shortest string, check if all others start with it, shorten until match	O(S²)	O(1)	❌
Horizontal Scanning	Compare prefix of first 2 strings, then compare with the next, and so on	O(S)	O(1)	✅ (Our Current Solution)
Vertical Scanning	Compare characters column-wise for all strings	O(S)	O(1)	✅ (Our Current Solution)
Divide and Conquer	Split array into halves, get LCP of each half, merge results	O(S log n)	O(log n)	❌
Binary Search on Prefix Length	Check mid-length prefix for all strings, shrink/grow search	O(S log m)	O(1)	❌

🔗 Related Problems
LeetCode #14 - Longest Common Prefix

LeetCode #242 - Valid Anagram

LeetCode #28 - Find the Index of the First Occurrence in a String

LeetCode #49 - Group Anagrams

🎯 Pattern Recognition
This is a string scanning problem.

The pattern here: Compare incrementally and stop on first mismatch.

Similar pattern in:

Checking common suffixes

Detecting shared substrings in a list

Matching DNA sequences prefix

🧠 Memory Tip
"Prefix is like friendship — the first fight ends it."
When scanning left to right, stop at the first mismatch — whatever was before is your LCP.
If you remember this analogy, you’ll recall the stopping condition instantly in interviews.