# ğŸ† Problem: Longest Common Prefix

## ğŸ“œ Problem Statement
Write a function to find the **longest common prefix** string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

### Example 1:
**Input:**  
`strs = ["flower","flow","flight"]`  
**Output:**  
`"fl"`

### Example 2:
**Input:**  
`strs = ["dog","racecar","car"]`  
**Output:**  
`""`  
**Explanation:** There is no common prefix among the input strings.

### Constraints:
- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` consists of only lowercase English letters if non-empty.

---

## ğŸ’¡ Intuition
Think of the **first word as a baseline** and try to match its characters one by one with all the other words.  
The moment a mismatch or an out-of-bound index is found in any word, you **stop right there** â€” because no longer prefix can exist beyond that point.

> Imagine the words stacked vertically:
f l o w e r
f l o w
f l i g h t

yaml
Copy
Edit
We check column by column:  
âœ… 'f' matches â†’ âœ… 'l' matches â†’ âŒ 'o' mismatches in the 3rd word â†’ Stop. Prefix = `"fl"`

---

## ğŸ§  Conceptual Understanding
- We **compare character by character** starting from index 0.
- We rely on the fact that **if the first mismatch happens at position `i`**, the longest common prefix must be from `0` to `i-1`.
- This is an **incremental matching approach** â†’ Itâ€™s optimal because:
  - We stop early when mismatch is found.
  - No extra space needed.

---

## â± Time and Space Complexity
| Complexity Type | Value |
|-----------------|-------|
| **Time**        | O(S) where S = sum of all characters in all strings (worst case compares each char) |
| **Space**       | O(1) â€” No extra space used beyond variables |

---

## ğŸŒ³ Recursion / Visualization (Test Case)
For input: `["flower", "flow", "flight"]`

Step 0: f l o w e r
f l o w
f l i g h t
â†‘
Match (char 'f')

Step 1: f l o w e r
f l o w
f l i g h t
â†‘
Match (char 'l')

Step 2: f l o w e r
f l o w
f l i g h t
â†‘
Mismatch (char 'o' vs 'i') â†’ Stop

Final Prefix: "fl"

pgsql
Copy
Edit

---

## ğŸ’» Code Implementation (Java)
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        for (int i = 0; i < strs[0].length(); i++) {
            char c = strs[0].charAt(i);
            for (int j = 1; j < strs.length; j++) {
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
ğŸ”„ Other Possible Approaches
Approach	Idea	Time Complexity	Space Complexity	Current?
Brute Force	Take the shortest string, check if all others start with it, shorten until match	O(SÂ²)	O(1)	âŒ
Horizontal Scanning	Compare prefix of first 2 strings, then compare with the next, and so on	O(S)	O(1)	âœ… (Our Current Solution)
Vertical Scanning	Compare characters column-wise for all strings	O(S)	O(1)	âœ… (Our Current Solution)
Divide and Conquer	Split array into halves, get LCP of each half, merge results	O(S log n)	O(log n)	âŒ
Binary Search on Prefix Length	Check mid-length prefix for all strings, shrink/grow search	O(S log m)	O(1)	âŒ

ğŸ”— Related Problems
LeetCode #14 - Longest Common Prefix

LeetCode #242 - Valid Anagram

LeetCode #28 - Find the Index of the First Occurrence in a String

LeetCode #49 - Group Anagrams

ğŸ¯ Pattern Recognition
This is a string scanning problem.

The pattern here: Compare incrementally and stop on first mismatch.

Similar pattern in:

Checking common suffixes

Detecting shared substrings in a list

Matching DNA sequences prefix

ğŸ§  Memory Tip
"Prefix is like friendship â€” the first fight ends it."
When scanning left to right, stop at the first mismatch â€” whatever was before is your LCP.
If you remember this analogy, youâ€™ll recall the stopping condition instantly in interviews.