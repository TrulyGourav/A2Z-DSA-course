# 1021. Remove Outermost Parentheses

## ğŸ“ Problem Statement
A valid parentheses string is either:
- `""` (empty string)
- `"(" + A + ")"` where `A` is a valid parentheses string
- `A + B` where `A` and `B` are valid parentheses strings

A **primitive** valid parentheses string is non-empty and cannot be split into two non-empty valid parentheses strings.

**Task:**  
Given a valid parentheses string `s`, decompose it into primitive parts and remove the **outermost parentheses** of each primitive string.

---

### Example 1:
**Input:**  
```
s = "(()())(())"
```
**Output:**  
```
"()()()"
```
**Explanation:**  
- Primitive decomposition: `"(()())"` + `"(())"`
- Remove outer parentheses: `"()()"` + `"()"` â†’ `"()()()"`

---

### Example 2:
**Input:**  
```
s = "(()())(())(()(()))"
```
**Output:**  
```
"()()()()(())"
```
**Explanation:**  
- Primitive decomposition: `"(()())"` + `"(())"` + `"(()(()))"`
- Remove outer parentheses: `"()()"` + `"()"` + `"()(())"`

---

### Example 3:
**Input:**  
```
s = "()()"
```
**Output:**  
```
""
```
**Explanation:**  
- Primitive decomposition: `"()"` + `"()"`
- Removing outer parentheses: `"" + ""` â†’ `""`

---

## ğŸŒŸ Intuition
When traversing the string:
- **Outer parentheses** are exactly the first `(` that starts a primitive and the last `)` that ends it.
- Maintain a **counter** `opened` to track the depth of parentheses.
- Append characters **only if they are not the very first `(` or last `)`** in the current primitive.

Think of it like this:  
- `"(()())"` â†’ Depth: 0 â†’ 1 â†’ 2 â†’ 1 â†’ 2 â†’ 1 â†’ 0  
- We skip adding when depth goes from `0 â†’ 1` or `1 â†’ 0`.

---

## ğŸ” Conceptual Understanding
- **Primitive String:** Cannot be split into two valid parts. For example:
  - `"(()())"` âœ… primitive
  - `"()()"` âŒ not primitive (can be split into `"()"` and `"()"`)
- The outermost layer in each primitive has **exactly one opening `(` at depth 1 and one closing `)` at depth 1**.
- Removing them means **skip adding the first `(` when depth=0** and **skip adding the last `)` when depth=1**.

---

## â± Time and Space Complexity
| Complexity | Analysis |
|------------|----------|
| **Time**   | `O(n)` â€” Single pass over string |
| **Space**  | `O(n)` â€” StringBuilder for output |

---

## ğŸŒ³ Recursion / Stack Depth Visualization
Example: `(()())(())`

```
Depth: 0 1 2 1 2 1 0 1 2 1 0
Char : ( ( ) ( ) ) ( ( ) )
Keep?: âœ— âœ“ âœ“ âœ“ âœ“ âœ— âœ— âœ“ âœ“ âœ—
```
**Result:** `()()()`

---

## ğŸ’» Code (Current Solution)
```java
class Solution {
  public String removeOuterParentheses(String s) {
    StringBuilder sb = new StringBuilder();
    int opened = 0;

    for (final char c : s.toCharArray())
      if (c == '(') {
        if (++opened > 1)
          sb.append(c);
      } else if (--opened > 0) { // c == ')'
        sb.append(c);
      }

    return sb.toString();
  }
}
```

---

## ğŸ“š Other Approaches (from Brute Force â†’ Optimized)

| Approach | Description | Time | Space | This Solution? |
|----------|-------------|------|-------|----------------|
| **1. Split & Process Each Primitive** | Find primitives by depth counter reset to 0, remove first & last char of each, append result | O(n) | O(n) | âŒ |
| **2. Stack-based** | Push `(` onto stack, pop when `)`, append to output if stack not empty | O(n) | O(n) | âŒ |
| **3. Depth Counter (Current)** | Maintain `opened` counter, skip adding first `(` and last `)` of each primitive | O(n) | O(n) | âœ… |

---

## ğŸ”— Related Problems
- [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)  
- [856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)  
- [1541. Minimum Insertions to Balance a Parentheses String](https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

---

## ğŸ§  Pattern Recognition
- **Depth-based processing** of balanced parentheses.
- This depth-tracking idea is reusable for problems involving **removing outer layers, calculating scores, or tracking nested structures**.

---

## ğŸ’¡ Memory Tip
> Imagine peeling an onion ğŸ§… â€” each primitive string is an onion.  
> You always remove **the outermost layer** (first and last parentheses) and keep the rest intact.  
> The `opened` counter is your "layer counter" â€” skip when entering the first layer and when exiting it.

---
