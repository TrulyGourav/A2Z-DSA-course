# 242. Valid Anagram ✅

## 📌 Problem Statement
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### Example 1:
```
Input:  s = "anagram", t = "nagaram"
Output: true
```

### Example 2:
```
Input:  s = "rat", t = "car"
Output: false
```

### Constraints:
- 1 <= s.length, t.length <= 5 * 10⁴  
- `s` and `t` consist of lowercase English letters.

**Follow-up:** What if the inputs contain Unicode characters? How would you adapt your solution?

---

## 🌟 Intuition
An **anagram** is simply a rearrangement of characters.  
👉 If two strings are anagrams, then:  
- They **must have the same length**.  
- They **must have the exact same frequency of each character**.  

So, checking whether two strings are anagrams boils down to verifying if they contain the same letters with the same counts.

---

## 🔍 Conceptual Understanding
We have multiple ways to compare character frequency:

1. **Sorting Method (Your Solution)**  
   - Sort both strings and compare if they become identical.  
   - If yes → `true` (they are anagrams).  

2. **HashMap / Frequency Array Method**  
   - Count occurrences of each character in both strings.  
   - Compare frequency counts.  

**Key Point:** Both solutions work, but sorting is simpler to implement while frequency counting is more optimal.

---

## 🧮 Time & Space Complexity

| Approach | Time Complexity | Space Complexity |
|----------|----------------|------------------|
| Sorting (current solution) | O(n log n) | O(1) / O(n) (depending on sorting implementation) |
| HashMap/Frequency Array | O(n) | O(1) (fixed 26 chars for lowercase letters) |
| Unicode Frequency Map | O(n) | O(k) (where k = unique characters in Unicode range) |

---

## 🌳 Visual Understanding (Small Test Case)

Example:  
`s = "rat"`, `t = "tar"`

Sorting both:
```
s → "art"
t → "art"
```
Since both are identical after sorting → ✅ Anagram.

---

## 💻 Code Solution (Sorting Approach ✅)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        char[] schar = s.toCharArray();
        char[] tchar = t.toCharArray();
        Arrays.sort(schar);
        Arrays.sort(tchar);
        return new String(schar).equals(new String(tchar));
    }
}
```

---

## 🧵 Other Approaches (without code)

1. **Brute Force (Check all permutations)**  
   - Generate all permutations of `s` and see if `t` exists.  
   - ❌ Complexity: O(n!) — impractical.  

2. **Sorting (Current Solution ✅)**  
   - Sort both strings and compare.  
   - Complexity: **O(n log n)**  

3. **HashMap / Frequency Count**  
   - Count frequency of each char in both strings.  
   - Compare counts.  
   - Complexity: **O(n)** (Better for large inputs).  

4. **Unicode Handling (Follow-up)**  
   - Instead of fixed 26-length array, use `HashMap<Character, Integer>` to handle arbitrary characters.  
   - Complexity: **O(n)**  

---

## 🔗 Related Problems
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)  
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)  
- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)  

---

## 🎯 Pattern Recognition
This problem belongs to the **"Anagram Pattern"**:  
- Sort or Count Frequencies → Compare.  
- Variants often appear with sliding windows (`find all anagrams`, `permutation in string`).  
- Core idea: **Character frequency matters, order doesn’t**.

---

## 🧠 Memory Tip
🔑 **Think "Sorting makes order disappear."**  
If two words become identical after sorting, they must be the same set of characters.  
👉 Whenever you see "Anagram", immediately think:  
**"Either sort OR count."**  
- Sorting = Easy but slower.  
- Counting = Faster and scalable.  

---
