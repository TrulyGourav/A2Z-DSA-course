# 242. Valid Anagram âœ…

## ðŸ“Œ Problem Statement
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### Example 1:
```
Input:  s = "anagram", t = "nagaram"
Output: true
```

### Example 2:
```
Input:  s = "rat", t = "car"
Output: false
```

### Constraints:
- 1 <= s.length, t.length <= 5 * 10â´  
- `s` and `t` consist of lowercase English letters.

**Follow-up:** What if the inputs contain Unicode characters? How would you adapt your solution?

---

## ðŸŒŸ Intuition
An **anagram** is simply a rearrangement of characters.  
ðŸ‘‰ If two strings are anagrams, then:  
- They **must have the same length**.  
- They **must have the exact same frequency of each character**.  

So, checking whether two strings are anagrams boils down to verifying if they contain the same letters with the same counts.

---

## ðŸ” Conceptual Understanding
We have multiple ways to compare character frequency:

1. **Sorting Method (Your Solution)**  
   - Sort both strings and compare if they become identical.  
   - If yes â†’ `true` (they are anagrams).  

2. **HashMap / Frequency Array Method**  
   - Count occurrences of each character in both strings.  
   - Compare frequency counts.  

**Key Point:** Both solutions work, but sorting is simpler to implement while frequency counting is more optimal.

---

## ðŸ§® Time & Space Complexity

| Approach | Time Complexity | Space Complexity |
|----------|----------------|------------------|
| Sorting (current solution) | O(n log n) | O(1) / O(n) (depending on sorting implementation) |
| HashMap/Frequency Array | O(n) | O(1) (fixed 26 chars for lowercase letters) |
| Unicode Frequency Map | O(n) | O(k) (where k = unique characters in Unicode range) |

---

## ðŸŒ³ Visual Understanding (Small Test Case)

Example:  
`s = "rat"`, `t = "tar"`

Sorting both:
```
s â†’ "art"
t â†’ "art"
```
Since both are identical after sorting â†’ âœ… Anagram.

---

## ðŸ’» Code Solution (Sorting Approach âœ…)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        char[] schar = s.toCharArray();
        char[] tchar = t.toCharArray();
        Arrays.sort(schar);
        Arrays.sort(tchar);
        return new String(schar).equals(new String(tchar));
    }
}
```

---

## ðŸ§µ Other Approaches (without code)

1. **Brute Force (Check all permutations)**  
   - Generate all permutations of `s` and see if `t` exists.  
   - âŒ Complexity: O(n!) â€” impractical.  

2. **Sorting (Current Solution âœ…)**  
   - Sort both strings and compare.  
   - Complexity: **O(n log n)**  

3. **HashMap / Frequency Count**  
   - Count frequency of each char in both strings.  
   - Compare counts.  
   - Complexity: **O(n)** (Better for large inputs).  

4. **Unicode Handling (Follow-up)**  
   - Instead of fixed 26-length array, use `HashMap<Character, Integer>` to handle arbitrary characters.  
   - Complexity: **O(n)**  

---

## ðŸ”— Related Problems
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)  
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)  
- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)  

---

## ðŸŽ¯ Pattern Recognition
This problem belongs to the **"Anagram Pattern"**:  
- Sort or Count Frequencies â†’ Compare.  
- Variants often appear with sliding windows (`find all anagrams`, `permutation in string`).  
- Core idea: **Character frequency matters, order doesnâ€™t**.

---

## ðŸ§  Memory Tip
ðŸ”‘ **Think "Sorting makes order disappear."**  
If two words become identical after sorting, they must be the same set of characters.  
ðŸ‘‰ Whenever you see "Anagram", immediately think:  
**"Either sort OR count."**  
- Sorting = Easy but slower.  
- Counting = Faster and scalable.  

---
