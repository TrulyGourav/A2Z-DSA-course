# 1903. Largest Odd Number in String

**Level:** Easy  
**Tags:** String, Greedy  
**Platform:** [LeetCode](https://leetcode.com/problems/largest-odd-number-in-string/)  

---

## ðŸ“ Problem Statement

You are given a string `num`, representing a large integer.  
Return the **largest-valued odd integer** (as a string) that is a **non-empty substring** of `num`, or an empty string `""` if no odd integer exists.

A **substring** is a contiguous sequence of characters within a string.

---

### Example 1:
**Input:**  
```
num = "52"
```  
**Output:**  
```
"5"
```  
**Explanation:**  
The substrings are `"5"`, `"2"`, and `"52"`. Only `"5"` is odd.

---

### Example 2:
**Input:**  
```
num = "4206"
```  
**Output:**  
```
""
```  
**Explanation:**  
There are no odd integers in `"4206"`.

---

### Example 3:
**Input:**  
```
num = "35427"
```  
**Output:**  
```
"35427"
```  
**Explanation:**  
The entire number is already odd.

---

## ðŸ’¡ Intuition (Highlighted)

When looking for the **largest odd number** thatâ€™s a substring,  
you **donâ€™t need to check all substrings**.  
Why?  
Because the largest-valued substring will **start at index `0`** and **end at the last odd digit from the right**.  
So, **just find the last odd digit in the string and cut everything after it**.

Think of it like trimming a rope from the right until it ends with an odd number.

---

## ðŸ§  Conceptual Understanding

1. **Odd Numbers Rule:**  
   A number is odd if its last digit is `1, 3, 5, 7, 9`.  
2. **Largest-valued substring:**  
   To maximize the value, we start from the leftmost position (`index 0`) and keep as much of the number as possible until the last odd digit is found.  
3. **Efficient Scan:**  
   Iterate **backwards** from the rightmost digit until the first odd digit appears â†’ Return substring from start to that digit.

---

## â³ Time & Space Complexity

| Operation        | Complexity |
|------------------|------------|
| Time Complexity  | **O(n)** (single backward pass) |
| Space Complexity | **O(1)** (no extra space used) |

---

## ðŸŒ³ Visualization (Example: `"4206354"`)

```
Index:  0 1 2 3 4 5 6
Digit:  4 2 0 6 3 5 4
                      â† start scanning from the end
                      4 (even) â†’ skip
                   5 (odd) â†’ found at index 5
Return substring from index 0 to 5 â†’ "420635"
```

---

## ðŸ’» Code Solution (Current Approach)

```java
class Solution {
  public String largestOddNumber(String num) {
    for (int i = num.length() - 1; i >= 0; --i)
      if ((num.charAt(i) - '0') % 2 == 1)
        return num.substring(0, i + 1);
    return "";
  }
}
```

---

## ðŸ”„ Other Possible Approaches

| Approach No. | Approach Description | Time Complexity | Space Complexity | Current Solution? |
|--------------|----------------------|-----------------|------------------|-------------------|
| 1 | **Brute Force:** Generate all substrings, check if odd, store max | O(nÂ²) | O(1) | âŒ |
| 2 | **Check from left to right:** Keep max substring found so far | O(n) | O(1) | âŒ |
| 3 | **Reverse scan until odd digit (Greedy)** | O(n) | O(1) | âœ… (this one) |

---

## ðŸ”— Related / Associated Problems
1. [LeetCode 2586 - Count the Number of Vowel Strings in Range](https://leetcode.com/problems/count-the-number-of-vowel-strings-in-range/)
2. [LeetCode 129 - Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)  
3. [LeetCode 9 - Palindrome Number](https://leetcode.com/problems/palindrome-number/)

---

## ðŸŽ¯ Pattern Recognition

- **Greedy Trimming from Right** â€” Find first digit that satisfies the condition from the end.
- **Last Digit Decides the Property** â€” Similar to checking parity or divisibility.
- **Prefix Preservation** â€” Largest number substring usually starts from leftmost index.

---

## ðŸ§  Memory Tip to Never Forget

> **"Oddness lives at the tail."**  
> Scan from the right until you catch the odd digit â€” keep everything before it.  
> If no odd digit exists, return empty.

Whenever you face a problem where the **last element decides the validity**,  
try scanning **backwards** â€” it often turns a brute force into O(n) magic. âœ¨

---
