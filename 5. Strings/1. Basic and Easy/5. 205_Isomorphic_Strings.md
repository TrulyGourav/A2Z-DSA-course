# 📝 205. Isomorphic Strings

## 📌 Problem Statement
Given two strings `s` and `t`, determine if they are **isomorphic**.

👉 Two strings are isomorphic if the characters in `s` can be replaced to get `t`.  
- All occurrences of a character must be replaced with another character **consistently**.  
- No two characters may map to the same character, but a character may map to itself.

---

### 🔹 Example 1
**Input:**  
`s = "egg"`, `t = "add"`

**Output:**  
`true`

**Explanation:**  
- Map `'e'` → `'a'`  
- Map `'g'` → `'d'`  

Both strings transform identically.

---

### 🔹 Example 2
**Input:**  
`s = "foo"`, `t = "bar"`

**Output:**  
`false`

**Explanation:**  
- `'o'` would need to map to both `'a'` and `'r'`, which breaks the rule.

---

### 🔹 Example 3
**Input:**  
`s = "paper"`, `t = "title"`

**Output:**  
`true`

---

### 🔹 Constraints
- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` and `t` consist of any valid ASCII character.

---

## 🌟 Intuition (Very Important)

Think of **patterns**.  
- Two strings are isomorphic **if they share the same character occurrence pattern**.  
- For example:  
  - `"egg"` → pattern = `0 1 1`  
  - `"add"` → pattern = `0 1 1`  
  ✅ Patterns match → Isomorphic.  

- `"foo"` → `0 1 1`  
- `"bar"` → `0 1 2`  
❌ Patterns differ → Not isomorphic.  

👉 The key is to ensure **both characters in `s` and `t` map consistently** to their last seen index.

---

## 🔍 Conceptual Understanding
We use **two hash maps**:  
- `charToIndex_s` for string `s`  
- `charToIndex_t` for string `t`  

At each index `i`:  
- Store the **last seen index** of `s[i]` and `t[i]`.  
- If they don’t match → ❌ Not isomorphic.  

This works because it enforces **1-to-1 mapping consistency** across both strings.

---

## ⏱️ Complexity Analysis
- **Time Complexity:** `O(n)` → we traverse the strings once.  
- **Space Complexity:** `O(1)` → maximum 256 characters (ASCII). Effectively constant.

---

## 🌳 Recursion/Mapping Tree (Visualization)

Example: `s = "paper"`, `t = "title"`  

```
p → t
a → i
p → t   (consistent ✅)
e → l
r → e
```

Both strings follow the **same transformation path**, hence isomorphic.

---

## 💻 Code Solution (Current Approach)

```java
class Solution {
  public boolean isIsomorphic(String s, String t) {
    Map<Character, Integer> charToIndex_s = new HashMap<>();
    Map<Character, Integer> charToIndex_t = new HashMap<>();

    for (Integer i = 0; i < s.length(); ++i) {
      if (charToIndex_s.put(s.charAt(i), i) != charToIndex_t.put(t.charAt(i), i))
        return false;
    }

    return true;
  }
}
```

---

## 🔄 Other Possible Approaches

| Approach | Description | Time | Space | Status |
|----------|-------------|------|-------|--------|
| **Brute Force** | For each char in `s`, try mapping to `t` and validate uniqueness each time (nested loop). | O(n²) | O(n) | ❌ Too slow |
| **Direct Character Mapping** | Use 2 arrays of size 256 for ASCII mapping, check forward and backward consistency. | O(n) | O(1) | ✅ Efficient |
| **Index Pattern Comparison (Current)** | Compare last seen indices of both chars using HashMaps. | O(n) | O(1) | ✅ (Current Solution) |

---

## 🔗 Related Problems
- [290. Word Pattern](https://leetcode.com/problems/word-pattern/)  
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)  
- [890. Find and Replace Pattern](https://leetcode.com/problems/find-and-replace-pattern/)  

👉 These problems also revolve around **pattern consistency and mappings**.

---

## 🎯 Pattern Recognition
This problem is a classic **“Pattern Matching / Bijective Mapping”** problem.  
If you ever see:  
- "Can one string/array be transformed into another by replacing/mapping consistently?"  
👉 Think of **Isomorphic Strings logic**.

---

## 🧠 Memory Tip
Think of writing both words with **indexes instead of characters**:  

- `"egg"` → `0 1 1`  
- `"add"` → `0 1 1`  
- `"foo"` → `0 1 1`  
- `"bar"` → `0 1 2`  

✅ If the index-patterns match → strings are isomorphic.  

📌 **Interview Hack:**  
👉 Always reduce to comparing **patterns**, not characters.  
This way, the problem becomes a simple "do both arrays look the same?" check.  
