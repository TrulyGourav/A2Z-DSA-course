# 1358. Number of Substrings Containing All Three Characters

**Difficulty:** Medium  
**Link:** [LeetCode - 1358](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/)

---

## 🧩 Problem Statement

Given a string `s` consisting **only** of characters `'a'`, `'b'`, and `'c'`, return the **number of substrings** that **contain at least one occurrence of all three characters**.

---

### ✨ Examples

#### Example 1:
```
Input:  s = "abcabc"
Output: 10
Explanation: Valid substrings → 
"abc", "abca", "abcab", "abcabc", 
"bca", "bcab", "bcabc", 
"cab", "cabc", 
"abc"
```

#### Example 2:
```
Input:  s = "aaacb"
Output: 3
Explanation: Valid substrings → "aaacb", "aacb", "acb"
```

#### Example 3:
```
Input:  s = "abc"
Output: 1
```

---

## 💡 Intuition (🔥 Most Important Part)

When we find a substring ending at index `r` that contains all three characters (`'a'`, `'b'`, `'c'`), then **any substring that starts from index `0` to `l-1` and ends at `r`** is also valid.  

👉 So, for each valid window `[l..r]` containing all three characters:
- There are `l` valid substrings ending at `r`.

➡️ We **slide the window** using two pointers (`l` and `r`) and **count such substrings**.

---

## 📚 Conceptual Understanding

- Maintain a **count array** of size 3 for `'a'`, `'b'`, and `'c'`.
- Expand `r` to include current character and update the count.
- Shrink the window from `l` as long as all three counts are > 0 (i.e., valid).
- Add `l` to the result, because it contributes `l` valid substrings ending at `r`.

---

## ⏱️ Time and Space Complexity

| Type         | Complexity |
|--------------|------------|
| Time         | O(n)       |
| Space        | O(1)       |

- **Why O(n)?** Each character is visited at most twice (once by `r`, once by `l`)
- **Why O(1)?** Only constant extra space for count array.

---

## 🌳 Window Shrinking Visualization (Using `"aaabc"`)

Let’s walk through with a dry-run:

```
String: a a a b c
Index:  0 1 2 3 4

→ Valid window first appears at index 2-4 ("abc")
→ `l = 0` → 3 substrings valid: "aaabc", "aabc", "abc"
```

---

## ✅ Code (Sliding Window)

```java
class Solution {
  public int numberOfSubstrings(String s) {
    int ans = 0;
    int[] count = new int[3];
    int l = 0;

    for (char c : s.toCharArray()) {
      ++count[c - 'a'];

      while (count[0] > 0 && count[1] > 0 && count[2] > 0)
        --count[s.charAt(l++) - 'a'];

      ans += l;
    }

    return ans;
  }
}
```

---

## 🧵 Other Possible Approaches

| Approach                     | Time Complexity | Space Complexity | Status        |
|-----------------------------|------------------|-------------------|---------------|
| Brute Force (check all substrings) | O(n²)             | O(1)              | 🚫 Not optimal |
| HashMap + Sliding Window         | O(n)              | O(1)              | ✅ (Current)   |
| 3-Pointer lastSeen index method  | O(n)              | O(1)              | ✅ Alternate   |

### ✳ Alternate Optimal (3-Pointer Idea)
Track last seen indices of `'a'`, `'b'`, `'c'`. At each step, take the **minimum of those indices** → that’s the farthest left where all three were present.

---

## 🔗 Related Problems (Recommended)

1. [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) (Sliding Window)
2. [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) (Harder version)
3. [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)
4. [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)

---

## 🧠 Pattern Recognition

- **Sliding Window**
- **Character Count/Frequency Array**
- **Two Pointers**
- **Substring ending at index `r` and starting from all left points where valid → count = `l`**

---

## 🧠 Memory Tip

> 📌 **“Every valid window ending at `r` contributes `l` substrings. Why? Because all substrings from `0` to `l-1` ending at `r` must also include all characters.”**

🧠 Just **remember how many substrings end at `r` when a window is valid = `l`**  
✅ Think of each `r` as an anchor, and `l` as how far back you can go while still being valid.

**🔁 Practice imagining sliding window and what makes a window "valid".**

---

## 🔥 Interview Tip

If they ask:
> "How would you count substrings with at least 3 distinct characters?"

👉 Think:
- HashMap / count array to **track frequency**
- **Sliding Window to shrink** until invalid
- For every valid end, count how many starts are valid (`l`!)

---

📌 **Save this pattern in your head** – it's GOLD for substring and sliding window-based questions.

---