
# 3. Longest Substring Without Repeating Characters

### ğŸŸ¨ Difficulty: Medium  
### ğŸ¢ Asked by: Amazon, Google, Facebook, Microsoft, Adobe, Bloomberg, Apple  

---

## ğŸ§¾ Problem Statement

Given a string `s`, find the **length of the longest substring** without repeating characters.

---

### ğŸ” Examples

| Input        | Output | Explanation           |
|--------------|--------|------------------------|
| `"abcabcbb"` | `3`    | `"abc"` is the longest |
| `"bbbbb"`    | `1`    | `"b"` is the longest   |
| `"pwwkew"`   | `3`    | `"wke"` is valid       |

> A **substring** is a contiguous block of characters. `"pwke"` is a subsequence, not a valid substring.

---

## âœ… Constraints
- `0 <= s.length <= 5 * 10â´`
- `s` consists of English letters, digits, symbols, and spaces.

---

## ğŸ’¡ Intuition (ğŸ”¥ Most Important â€“ Read First!)

To find the longest substring **without repeating characters**, we must **track the characters** we've seen and their **positions** so we donâ€™t include duplicates in the current window.

Hereâ€™s the intuition:
- Use a **sliding window** to maintain a window of non-repeating characters.
- If a **duplicate character** is encountered, **slide the windowâ€™s left side forward** until the duplicate is removed.
- Keep updating the **maximum length** during this process.

> Imagine walking with two fingers over the string, adjusting only when necessary, and never stepping back.

---

## ğŸ§  Conceptual Understanding

### ğŸ” Technique Used:
- **Two Pointers + Sliding Window**
- Dynamic window size

### ğŸ“¦ Data Structure:
- `HashSet` or `HashMap` to track character indices efficiently

---

## ğŸ§® Time and Space Complexity

| Complexity    | Value                  |
|---------------|------------------------|
| â±ï¸ Time       | `O(n)` â€” Every character visited at most twice |
| ğŸ§  Space      | `O(min(n, m))` where `m` is the size of the charset (e.g., 128 for ASCII) |

---

## ğŸŒ³ Sliding Window Visualization

Letâ€™s take the test case: `s = "abcabcbb"`

```
Start â†’ "abc" â†’ duplicate at 'a' â†’ slide start pointer
Window adjusts: now it's "bca"
Next duplicate at 'b' â†’ window = "cab"
Continue until "abc" again â†’ longest = 3
```

| Index | Char | Window     | Action                      | MaxLen |
|-------|------|------------|-----------------------------|--------|
| 0     | 'a'  | a          | Add                         | 1      |
| 1     | 'b'  | ab         | Add                         | 2      |
| 2     | 'c'  | abc        | Add                         | 3 âœ…   |
| 3     | 'a'  | bca        | Duplicate â†’ Slide Left      | 3      |
| ...   | ...  | ...        | ...                         | 3      |

---

## âœ… Final Code (Sliding Window Approach in Java)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int left = 0, right = 0, maxLen = 0;
        Set<Character> set = new HashSet<>();

        while (right < s.length()) {
            char currentChar = s.charAt(right);

            if (!set.contains(currentChar)) {
                set.add(currentChar);
                maxLen = Math.max(maxLen, right - left + 1);
                right++;
            } else {
                set.remove(s.charAt(left));
                left++;
            }
        }

        return maxLen;
    }
}
```

---

## ğŸ” Other Possible Approaches

| Approach                        | Description                                                                 | Time | Space | Status |
|--------------------------------|-----------------------------------------------------------------------------|------|-------|--------|
| ğŸ¢ Brute Force                 | Generate all substrings and check for duplicates                           | O(nÂ³) | O(n) | âŒ Not feasible |
| ğŸ‡ HashMap + Sliding Window    | Store char â†’ index mapping, skip duplicates in one step                    | O(n) | O(n) | âœ… Best (Optimized) |
| ğŸ§° Array as HashMap (ASCII)     | Fixed-size array instead of HashSet for speed (only for ASCII)             | O(n) | O(1) | âœ… Optimized |
| ğŸ·ï¸ Two Pointers + HashSet      | Our current solution â†’ adjust left as needed                              | O(n) | O(n) | â˜‘ï¸ (Current) |

---

## ğŸ”— Associated & Similar Problems

| Problem Name                                     | Link                                                                 |
|--------------------------------------------------|----------------------------------------------------------------------|
| Longest Repeating Character Replacement          | [LeetCode 424](https://leetcode.com/problems/longest-repeating-character-replacement) |
| Minimum Window Substring                         | [LeetCode 76](https://leetcode.com/problems/minimum-window-substring) |
| Longest Substring with At Most K Distinct Chars  | [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters) |
| Longest Palindromic Substring                    | [LeetCode 5](https://leetcode.com/problems/longest-palindromic-substring/) |

---

## ğŸ§  Pattern Recognition

> This belongs to the **Sliding Window + HashSet** pattern:
- "Find the longest/shortest/valid window"
- Use `left` and `right` pointers to maintain window
- HashSet/Map to track window constraints (unique, freq count, etc.)

---

## ğŸ“ Tip to Remember

ğŸ§© **Think of the window like an elastic band**:
- It **expands** (move `right`) until it **snaps** (duplicate found)
- Then **slides forward** (move `left`) to remove pressure (remove duplicate)
- Keep track of the **longest relaxed stretch**

ğŸ¯ *Mental Shortcut*:  
> â€œSlide right to grow, slide left to remove repeats.â€

â›³ **Never reset the window** â€” just shrink it until it's valid again.

---

## ğŸ“š Summary

- **Best technique**: Sliding Window with HashSet
- **Don't restart** window on duplicates â€” adjust `left` pointer
- Keep updating max length during each expansion
- Recognize this pattern for many "longest substring/window" problems

---

Happy coding! ğŸš€
