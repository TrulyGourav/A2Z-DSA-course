# 1423. Maximum Points You Can Obtain from Cards

**Difficulty:** Medium  
**Tag(s):** Sliding Window, Arrays, Prefix Sum, Optimization  
**Platform:** LeetCode  
🔗 [Leetcode Link](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

---

## 🧩 Problem Statement

There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array `cardPoints`.

In one step, you can take **exactly one card** either from the **start** or the **end** of the array. You must take **exactly `k` cards**.

Return the **maximum score** you can obtain by picking `k` cards this way.

---

### 🔍 Example 1:
```
Input: cardPoints = [1,2,3,4,5,6,1], k = 3  
Output: 12  
Explanation: Best choice is to take 6, 5, and 1 from the end → 6 + 5 + 1 = 12
```

### 🔍 Example 2:
```
Input: cardPoints = [2,2,2], k = 2  
Output: 4  
Explanation: Any 2 cards will give 4.
```

### 🔍 Example 3:
```
Input: cardPoints = [9,7,7,9,7,7,9], k = 7  
Output: 55  
Explanation: All cards are taken.
```

---

## 🌟 Intuition (💡 Must Read!)

> The twist is: you can pick from **either end**, but **exactly `k` cards** must be taken.

So, rather than brute-forcing all combinations, here’s the smarter idea:

- You are allowed to pick `k` cards — some from the **start**, some from the **end**.
- Imagine taking `i` cards from the start and `k - i` cards from the end, for all `i` from 0 to `k`.
- Try all such combinations and get the **maximum total sum**.
- This can be optimized using **Sliding Window**.

But instead of summing selected cards, flip your view:

> 🧠 What if you **don’t take `k` cards**, but rather **skip `n - k` cards in the middle**, and minimize the sum of those?

Then:
```
maxScore = totalSum - minSumOf(n - k) contiguous elements
```

---

## 🧠 Conceptual Understanding

This problem is best solved using:
- **Sliding window** technique to find a subarray of length `n-k` with minimum sum
- Subtracting this from total sum gives the maximum points we can get with exactly `k` picks

---

## ⏱️ Time and Space Complexity

| Complexity      | Value              |
|----------------|--------------------|
| Time           | O(n)               |
| Space          | O(1)               |

---

## 🌳 Visualizing the Sliding Window

Suppose:
```text
cardPoints = [1,2,3,4,5,6,1], k = 3 → n = 7
You must take 3 cards → leave 4 cards (n - k = 4)
So, find the min sum of any window of length 4.
```

Example:
```
Total Sum = 22
Window [2,3,4,5] → sum = 14 → 22 - 14 = 8
Window [3,4,5,6] → sum = 18 → 22 - 18 = 4
Window [4,5,6,1] → sum = 16 → 22 - 16 = 6
Window [1,2,3,4] → sum = 10 → 22 - 10 = 12 (Best!)
```

---

## ✅ Code (Optimal Sliding Window Approach)

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int total = 0;
        for (int point : cardPoints) total += point;

        int n = cardPoints.length;
        int windowSize = n - k;

        // Find the minimum sum of any window of size n-k
        int minSubarraySum = 0;
        for (int i = 0; i < windowSize; i++) {
            minSubarraySum += cardPoints[i];
        }

        int currSum = minSubarraySum;
        for (int i = windowSize; i < n; i++) {
            currSum += cardPoints[i] - cardPoints[i - windowSize];
            minSubarraySum = Math.min(minSubarraySum, currSum);
        }

        return total - minSubarraySum;
    }
}
```

---

## 🔁 Other Approaches (from Brute → Optimal)

| Approach                              | Time Complexity | Space | Status         |
|---------------------------------------|------------------|--------|----------------|
| Brute Force (Try all start/end combos)| Exponential      | O(k)   | ❌ Too slow     |
| Prefix + Suffix Sum                   | O(k)             | O(k)   | ✅ Accepted     |
| Sliding Window (current approach)     | O(n)             | O(1)   | ✅ Best (✅)     |

---

## 🔗 Related / Associated Problems

- [560. Subarray Sum Equals K (LeetCode)](https://leetcode.com/problems/subarray-sum-equals-k/) – Sliding window / prefix sum
- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/) – Sliding window to limit changes
- [198. House Robber](https://leetcode.com/problems/house-robber/) – Dynamic subarray decisions
- [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) – Kadane’s algorithm

---

## 🧠 Pattern Recognition

- Pick `k` items from both ends → Think **"leave `n-k` in the middle"**
- Optimal subarray problems → **Sliding Window**
- If you're asked to **take `k` items from edges**, it's equivalent to **leaving the worst middle section**

---

## 🎯 Memory Tip / Hack to Never Forget This

🧠 **“Don’t pick the best `k` – drop the worst `n-k`.”**

> Imagine your score is the total sum — but you're *forced* to skip `n-k` cards in one go. So make that skip hurt the least (i.e., skip the least sum).

💭 Try visualizing this like a video game:
- You have to pick `k` weapons from the edges
- But the game **removes `n-k` items** from the middle randomly — so you try to ensure they remove the **least powerful ones**.

🎯 **Keyword to remember this:**
> "**Leave the worst block — take the rest.**"

---

Happy Grinding 🚀  
Keep committing daily — you'll crush FAANG rounds in no time. Want to send the next problem? I'm ready.
