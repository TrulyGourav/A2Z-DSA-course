# 1423. Maximum Points You Can Obtain from Cards

**Difficulty:** Medium  
**Tag(s):** Sliding Window, Arrays, Prefix Sum, Optimization  
**Platform:** LeetCode  
ğŸ”— [Leetcode Link](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

---

## ğŸ§© Problem Statement

There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array `cardPoints`.

In one step, you can take **exactly one card** either from the **start** or the **end** of the array. You must take **exactly `k` cards**.

Return the **maximum score** you can obtain by picking `k` cards this way.

---

### ğŸ” Example 1:
```
Input: cardPoints = [1,2,3,4,5,6,1], k = 3  
Output: 12  
Explanation: Best choice is to take 6, 5, and 1 from the end â†’ 6 + 5 + 1 = 12
```

### ğŸ” Example 2:
```
Input: cardPoints = [2,2,2], k = 2  
Output: 4  
Explanation: Any 2 cards will give 4.
```

### ğŸ” Example 3:
```
Input: cardPoints = [9,7,7,9,7,7,9], k = 7  
Output: 55  
Explanation: All cards are taken.
```

---

## ğŸŒŸ Intuition (ğŸ’¡ Must Read!)

> The twist is: you can pick from **either end**, but **exactly `k` cards** must be taken.

So, rather than brute-forcing all combinations, hereâ€™s the smarter idea:

- You are allowed to pick `k` cards â€” some from the **start**, some from the **end**.
- Imagine taking `i` cards from the start and `k - i` cards from the end, for all `i` from 0 to `k`.
- Try all such combinations and get the **maximum total sum**.
- This can be optimized using **Sliding Window**.

But instead of summing selected cards, flip your view:

> ğŸ§  What if you **donâ€™t take `k` cards**, but rather **skip `n - k` cards in the middle**, and minimize the sum of those?

Then:
```
maxScore = totalSum - minSumOf(n - k) contiguous elements
```

---

## ğŸ§  Conceptual Understanding

This problem is best solved using:
- **Sliding window** technique to find a subarray of length `n-k` with minimum sum
- Subtracting this from total sum gives the maximum points we can get with exactly `k` picks

---

## â±ï¸ Time and Space Complexity

| Complexity      | Value              |
|----------------|--------------------|
| Time           | O(n)               |
| Space          | O(1)               |

---

## ğŸŒ³ Visualizing the Sliding Window

Suppose:
```text
cardPoints = [1,2,3,4,5,6,1], k = 3 â†’ n = 7
You must take 3 cards â†’ leave 4 cards (n - k = 4)
So, find the min sum of any window of length 4.
```

Example:
```
Total Sum = 22
Window [2,3,4,5] â†’ sum = 14 â†’ 22 - 14 = 8
Window [3,4,5,6] â†’ sum = 18 â†’ 22 - 18 = 4
Window [4,5,6,1] â†’ sum = 16 â†’ 22 - 16 = 6
Window [1,2,3,4] â†’ sum = 10 â†’ 22 - 10 = 12 (Best!)
```

---

## âœ… Code (Optimal Sliding Window Approach)

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int total = 0;
        for (int point : cardPoints) total += point;

        int n = cardPoints.length;
        int windowSize = n - k;

        // Find the minimum sum of any window of size n-k
        int minSubarraySum = 0;
        for (int i = 0; i < windowSize; i++) {
            minSubarraySum += cardPoints[i];
        }

        int currSum = minSubarraySum;
        for (int i = windowSize; i < n; i++) {
            currSum += cardPoints[i] - cardPoints[i - windowSize];
            minSubarraySum = Math.min(minSubarraySum, currSum);
        }

        return total - minSubarraySum;
    }
}
```

---

## ğŸ” Other Approaches (from Brute â†’ Optimal)

| Approach                              | Time Complexity | Space | Status         |
|---------------------------------------|------------------|--------|----------------|
| Brute Force (Try all start/end combos)| Exponential      | O(k)   | âŒ Too slow     |
| Prefix + Suffix Sum                   | O(k)             | O(k)   | âœ… Accepted     |
| Sliding Window (current approach)     | O(n)             | O(1)   | âœ… Best (âœ…)     |

---

## ğŸ”— Related / Associated Problems

- [560. Subarray Sum Equals K (LeetCode)](https://leetcode.com/problems/subarray-sum-equals-k/) â€“ Sliding window / prefix sum
- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/) â€“ Sliding window to limit changes
- [198. House Robber](https://leetcode.com/problems/house-robber/) â€“ Dynamic subarray decisions
- [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) â€“ Kadaneâ€™s algorithm

---

## ğŸ§  Pattern Recognition

- Pick `k` items from both ends â†’ Think **"leave `n-k` in the middle"**
- Optimal subarray problems â†’ **Sliding Window**
- If you're asked to **take `k` items from edges**, it's equivalent to **leaving the worst middle section**

---

## ğŸ¯ Memory Tip / Hack to Never Forget This

ğŸ§  **â€œDonâ€™t pick the best `k` â€“ drop the worst `n-k`.â€**

> Imagine your score is the total sum â€” but you're *forced* to skip `n-k` cards in one go. So make that skip hurt the least (i.e., skip the least sum).

ğŸ’­ Try visualizing this like a video game:
- You have to pick `k` weapons from the edges
- But the game **removes `n-k` items** from the middle randomly â€” so you try to ensure they remove the **least powerful ones**.

ğŸ¯ **Keyword to remember this:**
> "**Leave the worst block â€” take the rest.**"

---

Happy Grinding ğŸš€  
Keep committing daily â€” you'll crush FAANG rounds in no time. Want to send the next problem? I'm ready.
