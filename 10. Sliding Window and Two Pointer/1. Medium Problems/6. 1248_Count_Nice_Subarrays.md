
# 1248. Count Number of Nice Subarrays

## ğŸ“– Problem Statement
Given an array of integers `nums` and an integer `k`. A **continuous subarray** is called **nice** if there are exactly `k` **odd numbers** in it.

Return the **number of nice sub-arrays**.

### Examples:
**Example 1:**
```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The nice sub-arrays are [1,1,2,1] and [1,2,1,1].
```

**Example 2:**
```
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: No odd numbers, so no nice sub-arrays.
```

**Example 3:**
```
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
```

---

## ğŸ’¡ Intuition
Counting subarrays with **exactly** `k` odd numbers directly is hard. But:

> Any subarray with exactly `k` odds = Subarrays with at most `k` odd numbers âˆ’ Subarrays with at most `k - 1` odd numbers

This trick simplifies the problem using a **sliding window** to count subarrays with at most `k` odds.

---

## âš–ï¸ Time and Space Complexity
| Component | Complexity |
|----------|------------|
| Time     | O(n)       |
| Space    | O(1)       |

---

## ğŸ”§ Conceptual Understanding
We define a helper method `numberOfSubarraysAtMost(nums, k)` that returns how many subarrays have **at most `k` odd numbers**.

To get exactly `k` odd numbers, subtract:
```
numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)
```

In the sliding window:
- Expand the window by moving `r` to the right
- Count subarrays ending at `r` and starting from `l`
- If odds in the window exceed `k`, shrink the window from the left

---

## ğŸ’š Visual (Sliding Window Tree)
Example: nums = [1,1,2,1,1], k = 3

```
             [1,1,2,1] -> 3 odds
             [1,2,1,1] -> 3 odds

Visualizing windows:
Window (l..r):
[1] - 1 odd
[1,1] - 2 odds
[1,1,2] - 2 odds
[1,1,2,1] - 3 odds âœ”
[1,1,2,1,1] - 4 odds -> shrink from left
```

This tree isn't a recursion tree but a **window growth/shrink structure**.

---

## ğŸ“ Code
```java
class Solution {
  public int numberOfSubarrays(int[] nums, int k) {
    return numberOfSubarraysAtMost(nums, k) - numberOfSubarraysAtMost(nums, k - 1);
  }

  private int numberOfSubarraysAtMost(int[] nums, int k) {
    int ans = 0;
    for (int l = 0, r = 0; r <= nums.length;) {
      if (k >= 0) {
        ans += r - l;
        if (r == nums.length)
          break;
        if (nums[r] % 2 == 1)
          --k;
        ++r;
      } else {
        if (nums[l] % 2 == 1)
          ++k;
        ++l;
      }
    }
    return ans;
  }
}
```

---

## ğŸ”„ Other Approaches (Brute to Optimal)
| Approach | Description | Time | Space | This Solution |
|---------|-------------|------|-------|----------------|
| Brute Force | Check all subarrays and count odds | O(n^2) | O(1) | âŒ |
| Prefix Sum with HashMap | Count prefix sums based on odd count | O(n) | O(n) | âŒ |
| Sliding Window (atMost k - atMost k-1) | Count with two-pointer trick | O(n) | O(1) | âœ” |

---

## ğŸ”— Related/Subproblems
- [Leetcode 930 - Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/) â†’ similar prefix sum logic
- [Leetcode 1004 - Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/) â†’ sliding window with constraint

---

## âœ³ Pattern Recognition
- Sliding Window on **counts/conditions**
- Convert "exact k" to "at most k - at most k - 1"
- Applies to count-based subarray problems

---

## ğŸš€ Tip to Never Forget the Logic

> Think of a "nice" subarray as a **VIP section** with exactly `k` odd guests.
> But itâ€™s hard to count just VIPs directly. So, count all sections that allow up to `k` guests, and subtract those with up to `k-1`. Boom, only VIPs remain!

### Mnemonic:
> **"Nice = AtMost(k) - AtMost(k-1)"**
