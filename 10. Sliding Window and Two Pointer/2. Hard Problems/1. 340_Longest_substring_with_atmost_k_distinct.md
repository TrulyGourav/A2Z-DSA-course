# 340. Longest Substring with At Most K Distinct Characters

**Difficulty:** Medium  
**Link:** [Leetcode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)

---

## ðŸ§¾ Problem Statement

You are given a string `s` consisting only of lowercase alphabets and an integer `k`. Your task is to find the **length of the longest substring** that contains **at most `k` distinct characters**.

If no such substring exists, return `-1`.

---

### ðŸ” Examples

Input: s = "aabacbebebe", k = 3
Output: 7
Explanation: The longest substring with exactly 3 distinct characters is "cbebebe".

Input: s = "aaaa", k = 2
Output: -1
Explanation: There's no substring with 2 distinct characters.

Input: s = "aabaaab", k = 2
Output: 7
Explanation: The entire string "aabaaab" has only 2 unique characters: 'a' and 'b'.

yaml
Copy
Edit

---

## ðŸŒŸ Intuition

This is a **classic Sliding Window** + **HashMap** problem.

> âœ… We want the **longest window** that contains at most `k` distinct characters.

We use two pointers (`left`, `right`) to maintain the window. We slide the window while keeping track of character frequencies. If the number of distinct characters exceeds `k`, we shrink the window from the left.

**This is not about fixed-length substrings. We keep adjusting the window dynamically.**

---

## ðŸ§  Conceptual Understanding

- We slide the `right` pointer to include new characters.
- We use a `Map<Character, Integer>` to count characters.
- If map size exceeds `k`, we shrink the window from the `left`.
- After processing each valid window (with `<=k` unique characters), we update the result with `right - left + 1`.

---

## ðŸ“ˆ Time & Space Complexity

| Type           | Complexity         |
|----------------|--------------------|
| Time           | O(N), where N is the length of string |
| Space          | O(K) for HashMap storing up to K characters |

---

## ðŸŒ³ Sliding Window Tree Visual

Take test case: `"aabacbebebe"` and `k = 3`

Window movements (right expands, left contracts when needed):

a a b a c b e b e b e
^
| ^ ^ (right)
| (left)

Distinct chars at any point:
{'a', 'b', 'c'} -> okay
{'a', 'b', 'c', 'e'} -> too many! shrink window by moving left

pgsql
Copy
Edit

---

## âœ… Sliding Window Code (Java)

```java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if (s == null || s.length() == 0 || k == 0) return -1;

        Map<Character, Integer> map = new HashMap<>();
        int left = 0, maxLength = -1;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            map.put(c, map.getOrDefault(c, 0) + 1);

            while (map.size() > k) {
                char leftChar = s.charAt(left);
                map.put(leftChar, map.get(leftChar) - 1);
                if (map.get(leftChar) == 0) {
                    map.remove(leftChar);
                }
                left++;
            }

            if (map.size() <= k) {
                maxLength = Math.max(maxLength, right - left + 1);
            }
        }

        return maxLength == -1 ? -1 : maxLength;
    }
}
ðŸ§µ Other Approaches
Approach	Time	Space	Notes
Brute-force (all substrings)	O(N^3)	O(N)	Check each substring and count uniques
Sliding Window + Set	O(N)	O(K)	Optimized using HashSet/Map (âœ” current)
Sliding Window + LinkedHashMap	O(N)	O(K)	Keeps insertion order, helpful in some variants

ðŸ”— Relevant/Associated Problems
3. Longest Substring Without Repeating Characters

159. Longest Substring with At Most Two Distinct Characters

992. Subarrays with K Different Integers (harder, array variant)

ðŸ§  Pattern Recognition
This is part of the "variable sliding window" family.

Whenever a problem says:

"longest substring/array with at most/exactly k unique/valid elements..."
-- it's almost always a sliding window problem.

ðŸ’¡ Memory Tip (to never forget the logic)
ðŸ§  Tip:

Think of walking with a bag where you can carry only k different toys. Every time you get a new toy and exceed your limit, drop the oldest ones from the front until youâ€™re back within your limit. Measure how far you've walked.

ðŸ’¬ Visualize the hashmap as your bag, and the left pointer as your hand removing the toy when the bag is full.

This bag-packing analogy helps retain this logic for multiple sliding window questions!

ðŸ“š Keep this problem in your sliding window core list â€“ a pattern youâ€™ll see again and again in interviews.