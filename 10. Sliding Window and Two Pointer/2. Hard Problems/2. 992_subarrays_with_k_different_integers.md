# 992. Subarrays with K Different Integers (Hard)

## 🧩 Problem Statement

Given an integer array `nums` and an integer `k`, return the number of **good subarrays** of `nums`.

A **good subarray** is a contiguous subarray where the number of **distinct integers** is exactly `k`.

### 🔍 Example 1:

```
Input: nums = [1,2,1,2,3], k = 2  
Output: 7  
Explanation: The 7 subarrays are:  
[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]
```

### 🔍 Example 2:

```
Input: nums = [1,2,1,3,4], k = 3  
Output: 3  
Explanation: The 3 subarrays are:  
[1,2,1,3], [2,1,3], [1,3,4]
```

---

## 🌟 Intuition (Read this 3x to cement understanding!)

To count **subarrays with exactly K distinct integers**,  
we use this formula:

```
Exactly K = At most K - At most (K - 1)
```

This is based on a pattern that:
- "At most K" counts subarrays with **1 to K** distinct elements.
- So subtracting "at most (K-1)" gives subarrays with **exactly K** distinct elements.

It’s like slicing the **"K layer"** out of a full cake of 1 to K layers.

---

## 📘 Conceptual Understanding

### Why Not Brute Force?
A brute-force approach would involve checking **every subarray**, counting distinct elements using a Set → **O(n³)** in worst case!

### Optimized Strategy:
We use **sliding window + two pointers + HashMap** to:
- Keep track of counts of each integer
- Expand the window (right pointer)
- Shrink it from the left when we have too many distinct integers

Finally, we use the above formula to get exactly `K`.

---

## 🧠 Time & Space Complexity

| Metric               | Value            |
|----------------------|------------------|
| Time Complexity       | O(n) + O(n) = O(n) |
| Space Complexity      | O(n) (for HashMap) |

---

## 🌳 Sliding Window Tree (Visual Example)

Take `nums = [1,2,1,2,3], k = 2`:

We'll compute:
```
count(atMost(2)) - count(atMost(1))
```

Here's a zoom into how sliding window works:

```
→ [1]  (1 distinct)
→ [1,2]  (2 distinct) ✅
→ [1,2,1] (still 2) ✅
→ [1,2,1,2] ✅
→ [1,2,1,2,3] ❌ (3 distinct → slide left)
```

---

## ✅ Java Code (Optimized Sliding Window Approach)

```java
class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        return countAtMost(nums, k) - countAtMost(nums, k - 1);
    }

    private int countAtMost(int[] nums, int k) {
        int left = 0, right = 0, res = 0;
        Map<Integer, Integer> freqMap = new HashMap<>();

        for (right = 0; right < nums.length; right++) {
            // If this number is new to the window
            if (freqMap.getOrDefault(nums[right], 0) == 0) {
                k--;
            }

            freqMap.put(nums[right], freqMap.getOrDefault(nums[right], 0) + 1);

            // Shrink the window until we have at most k distinct
            while (k < 0) {
                freqMap.put(nums[left], freqMap.get(nums[left]) - 1);
                if (freqMap.get(nums[left]) == 0) {
                    k++;
                }
                left++;
            }

            // All subarrays ending at right and starting from left are valid
            res += right - left + 1;
        }

        return res;
    }
}

```

---

## 🧵 All Possible Approaches (from Brute Force to Optimal)

| Approach                            | Time Complexity | Space Complexity | Status |
|-------------------------------------|------------------|-------------------|--------|
| Brute Force (Check all subarrays)   | O(n³)            | O(n)              | ❌     |
| Brute Force + Set for distinct check| O(n²)            | O(n)              | ❌     |
| Sliding Window with HashMap         | O(n)             | O(n)              | ✅ (current) |
| Double Sliding Window using Two Maps| O(n)             | O(n)              | ✅ Alternative |

---

## 🔗 Related/Similar Problems

| Problem | Link |
|--------|------|
| 930. Binary Subarrays With Sum | [LeetCode 930](https://leetcode.com/problems/binary-subarrays-with-sum/) |
| 1248. Count Number of Nice Subarrays | [LeetCode 1248](https://leetcode.com/problems/count-number-of-nice-subarrays/) |
| 340. Longest Substring with At Most K Distinct Characters | [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/) |
| 76. Minimum Window Substring | [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/) |

---

## 🔁 Recognizable Patterns

- Sliding Window with Dynamic Size
- HashMap for character/integer count
- "Exactly = At most K - At most (K-1)" pattern → 🧠 must-know trick!
- Two-pointer range scanning

---

## 🧠 Tip to Remember This Solution Forever

**🎵 Think of it like music layers:**

> "To hear **exactly K** instruments,  
you must subtract all combinations with **K-1 or less** from all with **K or fewer**."

So just remember:
```
Exactly K = At most K - At most (K - 1)
```

Also: This pattern is SUPER COMMON for **counting exact subarrays** — note it in your pattern log!

---

```
📌 Pro Tip: Whenever you see "subarrays with exactly K [something]" — consider:
AtMost(K) - AtMost(K-1)
```