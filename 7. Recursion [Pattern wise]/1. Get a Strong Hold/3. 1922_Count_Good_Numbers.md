# ğŸ§® 1922. Count Good Numbers

## ğŸ“Œ Problem Statement
A digit string is **good** if:
- Digits at **even indices (0-based)** are **even digits** â†’ `{0, 2, 4, 6, 8}` (5 options)
- Digits at **odd indices** are **prime digits** â†’ `{2, 3, 5, 7}` (4 options)

Given an integer `n`, return the total number of good digit strings of length `n`. Since the answer can be large, return it modulo `10â¹ + 7`.

### ğŸ” Constraints
- `1 <= n <= 10Â¹âµ`

### ğŸ’¡ Examples
```
Input: n = 1
Output: 5

Input: n = 4
Output: 400

Input: n = 50
Output: 564908303
```

---

## ğŸ§  Intuition (â­ Highlighted)
The key insight is **position-based fixed digit choices**:
- Every even index can be filled with **5** choices (even digits)
- Every odd index can be filled with **4** choices (prime digits)

If `n` is large, instead of generating all strings, we use **modular exponentiation**:
- Total = (5 ^ even_positions) * (4 ^ odd_positions) mod `10â¹ + 7`

This allows us to compute results even for `n` as large as `10^15`.

---

## ğŸªœ Approach
1. Let `even_positions = (n + 1) / 2` â†’ handles both odd and even `n`
2. Let `odd_positions = n / 2`
3. Compute:
   - `5 ^ even_positions mod MOD`
   - `4 ^ odd_positions mod MOD`
4. Multiply both results under modulo `10â¹ + 7`

Use **modular exponentiation** for efficiency: `O(log n)` time.

---

## ğŸ•µï¸ Conceptual Understanding
- Recognize **pattern-based digit restrictions**
- Use **modular exponentiation** for large exponents
- Understand that digit strings = **independent digit choices**
- This falls under the **combinatorics with fixed options per position** pattern

---

## â±ï¸ Time and Space Complexity

| Complexity | Value     |
|------------|-----------|
| â³ Time     | `O(log n)` â€” due to exponentiation |
| ğŸª« Space    | `O(log n)` â€” recursive call stack (can be optimized to `O(1)` using iterative pow) |

---

## ğŸ’» Code (Java)
```java
class Solution {
  public int countGoodNumbers(long n) {
    return (int) (modPow(4 * 5, n / 2) * (n % 2 == 0 ? 1 : 5) % MOD);
  }

  private static final int MOD = 1_000_000_007;

  private long modPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n % 2 == 1)
      return x * modPow(x, n - 1) % MOD;
    return modPow(x * x % MOD, n / 2);
  }
}
```

---

## ğŸ”„ Other Possible Approaches (No Code)

### âœ… Iterative Modular Exponentiation:
- Use a loop to compute power instead of recursion.
- Avoids call stack growth.
- Time: `O(log n)`

### âœ… Separate Power Calculation:
- Instead of multiplying `(4 * 5)` and using one `modPow`, compute:
  - `modPow(5, even_positions)`
  - `modPow(4, odd_positions)`
- Time: `O(log n)`  
- Clearer in terms of logic and more adaptable for similar problems.

---

## ğŸ§  Pattern Recognition Tips

- **Digit Constraint Problems** â†’ Focus on independent positions
- If constraints are on **index parity**, count even and odd indices separately
- For **large `n`**, always consider **modular exponentiation**
- Questions like this often appear in variations (e.g., binary strings, bit manipulation)