# 📘 Count Subsequences with Sum = K

## 🔹 Problem Statement
Given an array `nums` and an integer `k`, return the number of **non-empty subsequences** of `nums` such that the **sum of all elements in the subsequence equals `k`**.

---

## 🔹 Examples

**Example 1**  
Input:  
`nums = [4, 9, 2, 5, 1] , k = 10`  
Output:  
`2`  
Explanation: The possible subsequences are `[9, 1]`, `[4, 5, 1]`.

---

**Example 2**  
Input:  
`nums = [4, 2, 10, 5, 1, 3] , k = 5`  
Output:  
`3`  
Explanation: The possible subsequences are `[4, 1]`, `[2, 3]`, `[5]`.

---

## 🔹 Intuition
The problem screams **subsequence generation**.  
Whenever you see *"count subsequences / subsets with condition"*, the typical pattern is:

1. At each element → we have **2 choices**:
   - **Include it** in the subsequence.
   - **Exclude it**.
2. Keep track of the running sum.
3. When we reach the end:
   - If sum equals `k`, **count this subsequence**.
   - Otherwise, ignore.

👉 This forms a **binary recursion tree** (include/exclude), and is a classic application of **DFS recursion on arrays**.

---

## 🔹 Conceptual Understanding

For `nums = [4, 2, 1] , k = 3`

Recursion Tree (subproblem breakdown):

```
Index 0 → nums[0] = 4
                (sum=0)
               /       \
         include 4     exclude 4
         (sum=4)         (sum=0)
         /    \           /    \
   include 2  exclude 2 include 2 exclude 2
   (sum=6)     (sum=4)   (sum=2)   (sum=0)
      ...         ...       ...       ...
```

- Only branches where **sum = k at the leaf** are counted.
- This explores **all subsequences** naturally.

---

## 🔹 Recursive Solution (Java)

```java
class Solution {
    public int countSubsequenceWithTargetSum(int[] nums, int k) {
        return countHelper(nums, 0, 0, k);
    }

    private int countHelper(int[] nums, int index, int currentSum, int target) {
        // ✅ Base case: reached end of array
        if (index == nums.length) {
            // if sum matches target → count 1 subsequence
            return currentSum == target ? 1 : 0;
        }

        // Choice 1: Include current element
        int include = countHelper(nums, index + 1, currentSum + nums[index], target);

        // Choice 2: Exclude current element
        int exclude = countHelper(nums, index + 1, currentSum, target);

        // Total subsequences
        return include + exclude;
    }
}
```

---

## 🔹 Time & Space Complexity
- **Time Complexity**:  
  - At each index → 2 choices → O(2^n)  
  - Worst case explores all subsequences.
- **Space Complexity**:  
  - Recursion depth = O(n) (stack space).

---

## 🔹 Other Approaches (Summary)

| Approach | Idea | Time | Space | Current Solution? |
|----------|------|------|-------|-------------------|
| Brute Force | Generate all subsequences explicitly, check sum | O(n·2^n) | O(n) | ❌ |
| Recursive Backtracking | Include/Exclude strategy | O(2^n) | O(n) | ✅ (Current) |
| Memoization (DP) | Cache `(index, sum)` to avoid recomputation | O(n·k) | O(n·k) | ❌ |
| Bottom-Up DP | Classic subset sum count (similar to knapsack) | O(n·k) | O(k) | ❌ |

---

## 🔹 Related / Associated Problems
- [LeetCode 494: Target Sum](https://leetcode.com/problems/target-sum/)  
- [LeetCode 416: Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)  
- [LeetCode 698: Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)  
- [LeetCode 518: Coin Change II](https://leetcode.com/problems/coin-change-ii/)

---

## 🔹 Pattern Recognition
- This problem is part of the **Subset/Knapsack family**:
  - "Include/Exclude" choice → **Subsequence/Subset generation**
  - "Target sum" → **Subset Sum Problem**
- Same pattern applies to:
  - Counting subsets
  - Finding subsets
  - Minimum difference partition
  - Target sum with +/- signs

---

## 🧠 Tip to Never Forget
Think like this:  
👉 **"Every element can either join the subsequence party or stay out."**  
- If it joins, it adds to the sum.  
- If it doesn’t, we move on.  
At the end, we only count the parties (subsequences) whose **total bill (sum) = k**.  

This "Party Analogy" makes the include/exclude recursion unforgettable. 🎉
